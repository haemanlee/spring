# Day 1 — 주문(Order) 이론 + 사례 학습 노트

> 목표: 주문 도메인을 실무 BP(Best Practice) 관점으로 이해하고, 바로 구현 가능한 수준의 설계 감각을 만든다.

## 1) 오늘의 학습 목표
- 주문 도메인의 **경계(Bounded Context)** 를 나눌 수 있다.
- 주문 상태를 `Enum` 또는 코드 테이블 중 어떤 방식으로 관리할지 판단할 수 있다.
- 주문 생성 시점의 상품 정보를 왜 **스냅샷**으로 저장해야 하는지 설명할 수 있다.
- 상태 변경을 **이력(History) INSERT-only** 로 남겨 감사/분석 가능한 구조를 설계할 수 있다.

---

## 2) 핵심 이론 요약

### 2-1. 도메인 경계 분리
주문 시스템에서 최소한 다음 경계를 분리해 사고한다.

- `Order`: 고객 주문의 루트(주문번호, 주문자, 상태, 총액 등)
- `OrderItem`: 주문에 포함된 품목(상품 ID + 스냅샷 데이터)
- `Payment`: 결제 흐름(승인/취소/실패, PG 응답)
- `Shipment`: 배송 흐름(출고/배송중/완료, 운송장)

**왜 분리하는가?**
- 변경 주기가 다르다. (결제 정책 변경 vs 배송 정책 변경)
- 장애 영향도를 줄인다. (결제 장애가 주문 조회 전체 장애로 번지는 것 방지)
- 책임이 명확해져 유지보수가 쉬워진다.

### 2-2. 상태 모델링: Enum vs 코드 테이블

#### Enum이 적합한 경우
- 상태 종류가 적고 자주 변하지 않는다.
- 상태에 붙는 메타데이터가 거의 없다.
- 코드 레벨 컴파일 안전성이 중요하다.

예: `CREATED`, `PAID`, `SHIPPED`, `DELIVERED`, `CANCELED`

#### 코드 테이블이 적합한 경우
- 운영 중 상태 추가/비활성화가 필요하다.
- 다국어 라벨, 정렬 순서, 화면 색상 등 메타데이터가 많다.
- 관리자 화면에서 상태 정책을 관리하고 싶다.

### 2-3. 스냅샷(반정규화) 저장
주문 시점 상품명/가격/옵션을 `OrderItem`에 함께 저장한다.

**핵심 이유**
- 상품 마스터 데이터는 시간이 지나며 바뀐다.
- 과거 주문의 금액 정합성/법적 증빙을 지키려면 “당시 값”이 필요하다.

즉, `productId`만 저장하면 안 되고,
- `productNameSnapshot`
- `unitPriceSnapshot`
- `optionSnapshot`(필요 시 JSON)
등을 함께 저장해야 한다.

### 2-4. 상태 이력: INSERT-only
`orders.status`는 현재 상태만 갖고,
상태 변화는 `order_status_histories`에 누적한다.

- 현재 상태 조회: 빠름 (`orders.status`)
- 변경 추적/감사/분석: 이력 테이블 활용
- 데이터 신뢰성: UPDATE/DELETE 최소화로 추적성 확보

---

## 3) 실무 사례

### 사례 A — “상품 가격 변경” 이슈
**상황**
- 3월 1일 주문 당시 상품 가격 10,000원
- 3월 5일 상품 마스터 가격이 12,000원으로 변경
- 3월 7일 고객이 3월 1일 주문 내역 조회

**잘못된 설계**
- 주문에서 상품 테이블만 조인해 현재 가격 표시
- 과거 주문 금액이 12,000원으로 보이는 오류 발생

**올바른 설계**
- `OrderItem.unitPriceSnapshot = 10,000` 저장
- 조회 시 스냅샷 우선 사용

### 사례 B — “상태 변경 분쟁” 이슈
**상황**
- 고객: “나는 주문 취소를 안 했는데 취소됨”
- 운영팀: 원인 파악 필요

**이력이 없는 설계의 문제**
- 현재 상태만 `CANCELED`로 남아 원인 불명

**이력이 있는 설계의 해결**
- `from_status`, `to_status`, `changed_by`, `created_at`로
  누가 언제 어떤 흐름으로 바꿨는지 확인 가능

### 사례 C — “중복 상태 변경 요청”
**상황**
- 네트워크 재시도로 동일 상태 변경 API가 연속 호출됨

**권장 처리**
- 현재 상태와 동일한 변경 요청은 no-op 처리
  - **no-op(노옵)** = "요청은 정상으로 받았지만, 이미 같은 상태라서 실제 변경 작업은 하지 않음"
  - 예: 이미 `PAID`인 주문에 다시 `PAID` 요청이 오면 DB UPDATE/이력 INSERT 없이 그대로 성공 응답
  - 장점: 중복 호출/재시도 상황에서 데이터 꼬임(중복 이력, 불필요한 락/쓰기) 방지
- 필요 시 idempotency key 적용
- 동시성 높은 구간은 `findByIdForUpdate` 같은 잠금 전략 고려

---

## 4) Day 1 실습 체크리스트

- [x] 주문 엔티티에 `status`와 `orderNo(unique)`를 정의했다. *(사례1 구현 완료)*
- [x] 주문 품목에 상품 스냅샷 필드(이름/가격)를 포함했다. *(사례1 구현 완료)*
- [x] 상태 변경 시 이력 INSERT를 함께 수행한다. *(사례2 구현 완료)*
- [x] 상태 변경 API에서 동일 상태 요청을 no-op 처리했다. *(사례2 구현 완료)*
- [ ] 이력 조회 인덱스 `(order_id, created_at)`를 고려했다.

---

## 5) 면접/실무 답변 템플릿

**Q. 왜 주문 품목에 상품 스냅샷을 저장하나요?**
> 상품 마스터는 변경될 수 있으므로, 과거 주문의 정합성과 증빙을 위해 주문 시점 값을 별도로 보존해야 합니다.

**Q. 상태를 Enum으로 할지 코드 테이블로 할지 기준은?**
> 상태 변경 빈도와 메타데이터 필요성을 기준으로 봅니다. 고정 상태는 Enum, 운영 중 동적 관리가 필요하면 코드 테이블이 적합합니다.

**Q. 상태 이력 테이블이 꼭 필요한가요?**
> 운영 분쟁, 감사, 장애 원인 분석, SLA 측정까지 고려하면 필수에 가깝습니다. 현재 상태 컬럼 + 이력 누적 구조를 함께 쓰는 것이 실무적으로 가장 안정적입니다.

---

## 6) 내일(Day 2) 예고
- 주문 생성 유스케이스 구현 (`Order` + `OrderItem` 저장)
- 상태 변경 서비스 구현 (락 + 이력 저장)
- 조회 최적화 기본 (`OrderSummary` DTO 조회)
